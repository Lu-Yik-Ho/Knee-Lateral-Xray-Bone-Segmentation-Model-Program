import torch
import pydicom # type: ignore
import os
import glob
import numpy as np
import json
import torch.utils.data
import torchvision
from torchvision import transforms
from PIL import Image
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import shutil
import ultralytics# type: ignore
import cv2
os.environ['YOLO_VERBOSE'] = 'false'
from ultralytics import YOLO # type: ignore
from sklearn.model_selection import train_test_split
import yaml


def apply_clahe(file, output_dir):

    """
    **Applies CLAHE normalisation on an image.**

    Parameters:

        file (png): The path to the image file.

        output_dir (str): The directory for storing output files.

    Returns:
    
        output (png): A CLAHE normalised image stored in the specified output directory.
    """

    # 
    img = cv2.imread(file, cv2.IMREAD_GRAYSCALE)

    # 
    clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8))
    clahe_img = clahe.apply(img)

    file_name = os.path.splitext(file)[0]
    output_path = os.sep.join([output_dir, file_name.split(os.sep)[-1] + ".png"])
    cv2.imwrite(output_path,clahe_img)

    return None


def calculatePredictBox(result):
    
    """
    **Collects information defining a bounding box from a model prediction result.**

    Parameters:

        result (ultralytics.engine.results.Results): A model prediction result.

    Returns:
    
        output (dict): A dictionary containing important information with keys. See predict_box below.
    """

    # Collect information from result
    img_height, img_width = result.orig_shape

    x_min = result.boxes.xyxy[0][0]
    y_min = result.boxes.xyxy[0][1]
    x_max = result.boxes.xyxy[0][2]
    y_max = result.boxes.xyxy[0][3]
    x_center = result.boxes.xywh[0][0]
    y_center = result.boxes.xywh[0][1]
    box_width = result.boxes.xywh[0][2]
    box_height = result.boxes.xywh[0][3]

    # Output dictionary
    predict_box = {
        "path": result.path, # Path to image file
        "x_min": x_min, # X value of top left corner of bounding box
        "y_min": y_min, # Y value of top left corner of bounding box
        "x_max": x_max, # X value of bottom right corner of bounding box
        "y_max": y_max, # Y value of bottom right corner of bounding box
        "x_center": x_center, # X value of center of bounding box
        "y_center": y_center, # Y value of center of bounding box
        "box_width": box_width, # Width of bounding box
        "box_height": box_height, # Height of bounding box
        "img_width": img_width, # Width of image
        "img_height": img_height # Height of image
    }

    return predict_box


def calculateSquareBox(box, adjust = "Vertical"):

    """
    **Converts a rectanglular bounding box to a square bounding box.**

    Change adjust parameter to change how the square is defined.

    Parameters:
        box (dict): Dictionary with information of a bounding box generated by calculatePredictBox() or calculateTruthBox(). View these functions to view dictionary structure.

        adjust (str): String with expected values. Controls how the square is defined from bounding box.
        
            "Horizontal": Crops or expands from the left side and right side of the bounding box equally to match the width with the height.

            "Left": Crops or expands from the left side of the bounding box to match the width with the height.

            "Right": Crops or expands from the right side of the bounding box to match the width with the height.

            "Vertical": Crops or expands from the top and the bottom of the bounding box equally to match the height with the width.

            "Top": Crops or expands from the top of the bounding box to match the height with the width.

            "Bottom": Crops or expands from the bottom of the bounding box to match the height with the width.

            "None": Bypasses this function, returns original bounding box without error message.

            Other values: Returns original bounding box with an error message.

    Returns:
        output (dict): Dictionary with updated square bounding box information. Remains in same structure as original box.
    
        Returns original dictionary if "adjust" parameter has an unexpected value or if the bounding box was already square.

    """
    # Load information from dictionary as temporary variables
    x_min = box["x_min"]
    y_min = box["y_min"]
    box_width = box["box_width"]
    box_height = box["box_height"]
    img_width = box["img_width"]
    img_height = box["img_height"]

    # Check if the bounding box is square. Returns original dictionary if true.
    if box_height == box_width:
        print("Image already square!. Image path: {}".format(box["path"]))
        return box      
    
    # Base value to be adjusted 
    adjust_num = abs(box_width - box_height)/2

    # Check if adjust has unexpected value. Returns original dictionary if true.
    if adjust not in ["Horizontal", "Vertical", "Top", "Bottom", "Left", "Right", "None"]:
        print("Unexpected value for adjust parameter! Conversion abandoned. Image path: {}".format(box["path"]))
        return box
    
    if adjust == "None":
        return box
    
    if adjust == "Horizontal": # Change width to match height, crop/expand from left side and right side of bounding box equally
        if box_width > box_height: 
            # Crop
            new_x_min = x_min + adjust_num
            new_y_min = y_min
            new_box_width = box_height
            new_box_height = box_height
        else: 
            # Expand
            new_x_min = x_min - adjust_num
            new_y_min = y_min
            new_box_width = box_height
            new_box_height = box_height

    if adjust == "Left": # Change width to match height, crop/expand from left side of bounding box
        if box_width > box_height: 
            # Crop
            new_x_min = x_min + 2*adjust_num
            new_y_min = y_min
            new_box_width = box_height
            new_box_height = box_height
        else: 
            # Expand
            new_x_min = x_min - 2*adjust_num
            new_y_min = y_min
            new_box_width = box_height
            new_box_height = box_height

    if adjust == "Right": # Change width to match height, crop/expand from right side of bounding box
        # Crop / Expand
        new_x_min = x_min
        new_y_min = y_min
        new_box_width = box_height
        new_box_height = box_height

    if adjust == "Vertical": # Change height to match width, crop/expand from top and bottom of bounding box equally
        if box_height > box_width:
            # Crop
            new_x_min = x_min 
            new_y_min = y_min + adjust_num
            new_box_width = box_width
            new_box_height = box_width
        else: 
            # Expand
            new_x_min = x_min 
            new_y_min = y_min - adjust_num
            new_box_width = box_width
            new_box_height = box_width

    if adjust == "Top": # Change height to match width, crop/expand from top of bounding box
        if box_height > box_width:
            # Crop
            new_x_min = x_min 
            new_y_min = y_min + 2*adjust_num
            new_box_width = box_width
            new_box_height = box_width
        else: 
            # Expand
            new_x_min = x_min 
            new_y_min = y_min - 2*adjust_num
            new_box_width = box_width
            new_box_height = box_width

    if adjust == "Bottom": # Change height to match width, crop/expand from bottom of bounding box
        # Crop / Expand
        new_x_min = x_min 
        new_y_min = y_min 
        new_box_width = box_width
        new_box_height = box_width
    
    # Calculate the bottom right corner of the bounding box
    new_x_max = new_x_min + new_box_width
    new_y_max = new_y_min + new_box_height

    # Checks if any values of the top left and the bottom right corners exceed the range of the original image
    # Adjust the value to the maximum and minimum within the image if any value exceeds, and displays a error message
    # Updates all values of the original dictionary
    invalid_report = 0

    box["x_min"] , invalid_report = (new_x_min , invalid_report) if  new_x_min >= 0 else (0 , invalid_report + 1)
    box["y_min"] , invalid_report = (new_y_min , invalid_report) if  new_y_min >= 0 else (0 , invalid_report + 1)
    box["x_max"] , invalid_report = (new_x_max , invalid_report) if  new_x_max <= img_width else (img_width , invalid_report + 1)
    box["y_max"] , invalid_report = (new_y_max , invalid_report) if  new_y_max <= img_height else (img_height , invalid_report + 1)

    if invalid_report > 0:
        print("The final image will not be square as the calculated square exceeds image range.")
    
    # Calculate and update remaining values in original dictionary
    box["x_center"] = (box["x_min"] + box["x_max"])/2
    box["y_center"] = (box["y_min"] + box["y_max"])/2
    box["box_width"] = box["x_max"] - box["x_min"]
    box["box_height"] = box["y_max"] - box["y_min"]

    return box


def crop_img(image_file, out_dir, x_min, y_min, box_width, box_height):

    """
    **Crops an image based on the provided bounding box information.**

    Parameters:

        image_file (png): The path to the image file.

        output_dir (str): The directory for storing output files.

        x_min (float): The x-value of the top left corner.

        y_min (float): The y-value of the top left corner.

        box_width (float): The width of the bounding box.

        box_height (float): The height of the bounding box.

    Returns:
    
        output (png): A cropped image stored in the specified output directory.
    """

    img = Image.open(image_file)

    cropped_img = transforms.functional.crop(img,y_min,x_min,box_height,box_width)

    file_name = os.path.splitext(image_file)[0]
    output_file = os.sep.join([out_dir, file_name.split(os.sep)[-1]+".png"])

    print(output_file)
    with open(str(output_file), 'wb') as png_file:
      cropped_img.save(png_file, "PNG")


def dicom_to_png(file):

    """
    **Retrieves a PNG image from a DICOM file.**

    Parameters:

        file (png): The path to the DICOM file.

    Returns:
    
        output (png): An image stored in the directory of the original DICOM file.
    """
    # read dicom image
    ds = pydicom.dcmread(file)
    
    # get image data
    shape = ds.pixel_array.shape

    # Convert to float to avoid overflow or underflow losses.
    image_2d = ds.pixel_array.astype(float)

    # Rescaling grey scale between 0-255
    image_2d_scaled = (np.maximum(image_2d,0) / image_2d.max()) * 255.0

    # Convert to uint
    image_2d_scaled = np.uint8(image_2d_scaled)

    # Write the PNG file
    output_filename = os.path.splitext(file)[0] + '.png'
    with open(output_filename, 'wb') as png_file:
        Image.fromarray(image_2d_scaled).save(png_file, "PNG")


def flip_png(file):
    
    """
    **Flips an image horizontally.**

    Parameters:

        file (png): The path to the image file.

    Returns:
    
        output (png): A flipped image stored in the directory of the original image.
    """

    # Open the image file
    img = Image.open(file)

    # Convert to PyTorch Tesnor (Needed for transforms module)
    img_tensor = transforms.functional.pil_to_tensor(img)

    # Horizontal Flip
    flipped_img_tensor = transforms.functional.hflip(img_tensor)

    # Convert to PIL image
    flipped_img = transforms.functional.to_pil_image(flipped_img_tensor)
    

    # Write the PNG files
    base_filename = os.path.splitext(file)[0]
    with open(base_filename + '_F.png', 'wb') as png_file:
      flipped_img.save(png_file, "PNG")


def normal_img(file, output_img = False, output_dir = None):

    """
    **Applies normalisation on an image.**

    Parameters:

        file (png): The path to the image file.

        output_img (bool): Whether to output the image. Default: False.

        output_dir (str): The directory for storing output files.        

    Returns:
    
        output (png): A normalised image stored in the specified output directory.
    """

    # Opens image file as PIL
    img = Image.open(file)

    # Converts PIL data to PyTorch tensor
    img_tensor = transforms.functional.pil_to_tensor(img)

    # Find the highest value of the image (tensor)
    max_value = torch.max(img_tensor)
    min_value = torch.min(img_tensor)
    print(max_value, min_value)
    min_tensor = torch.ones(img_tensor.size()) * min_value

    # Normalise image
    img_tensor_normal = (img_tensor - min_tensor) / (max_value - min_value)

    # Convert tensor to PIL data
    normal_img = transforms.functional.to_pil_image(img_tensor_normal)

    # Output:
    if output_img:
       if output_img == True:
            base_filename = os.path.splitext(file)[0]
            temp_path = base_filename.split(os.sep)[:]
            output_path = os.path.join(output_dir,temp_path[-1])
            with open(str(output_path) + "_N.png", 'wb') as png_file:
                normal_img.save(png_file, "PNG")


def predict_img(model, image_file):
        
    """
    **Runs a prediction on an image with the loaded model.**

    Parameters:

        model (class 'ultralytics.models.yolo.model.YOLO'): Loaded model.

        file (png): The path to the image file.

    Returns:
    
        output (ultralytics.engine.results.Results): Result data of the prediction.
    """

    results = model.predict(source=image_file)
    return results[0]
